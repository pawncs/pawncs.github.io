---
title: 内核态与用户态
date: 2021-07-23 14:33:10
categories:
- linux
tags:
- note
---
<style>
.title1{
    font-size:36px;
    color:#e7767f;
    /* 桃红 */
}
.title2{
    font-size:29px;
    color:#176f58;
    /* 祖母绿 */
}
.title3{
    font-size:22px;
    color:#21a675;
    /* 石绿 */
}
.title4{
    font-size:15px;
    color:#a8cd34;
    /* 柳绿 */
}
.name{

    margin-left: auto;
    text-align: right;
    color: #d05667;
    margin-right: 10px;
    margin-top: 20px;
    /*海棠红*/
}
</style>


<div class="name">by pawncs</div>

-----

-----
<div class="title3">内核态和用户态</div>

<div class="title4">内核空间和用户空间</div>

+ 用户空间：  
    用户自己可以操作的空间，通常存放用户自己写的数据等。
+ 内核空间：
    系统内核操作的空间，通常存放系统内核的函数、接口等。

<div class="title4">内核态和用户态</div>

内核态和用户态是操作系统的两种运行级别。

> Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。

所有用户运行的进程，一开始都是处于用户态的，当其执行文件操作和网络数据发送等操作，则会用到部分内核态的功能，即会切换到内核态。

内核态具有一定的安全保护作用。

用户一般不能直接使用核心，而是通过核心的外壳程序（shell）来和核心沟通。

<div class="title4">Shell</div>

Shell:命令解释器(command Interpreter),包含：
+ 将使用者的命令翻译给核心（kernel）处理。
+ 将核心(kernel)的处理结果翻译给使用者。

-----
<div class="title3">区别</div>

实质是特权级的不同，内核态和用户态拥有不同的权限。

-----
<div class="title3">切换</div>

>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发sys_fork()的执行时，就切换到了内核态。


<div class="title4">用户态切换到内核态的三种方式</div>

+ 系统调用：  
    用户进程主动要求切换到内核态。核心机制是使用了操作系统为用户特别开放的中断实现。（例如LINUX的80h）。

+ 异常：  
    当CPU执行用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也即转入内核态。（如缺页异常）

+ 外围设备的中断：  
    外围设备完成用户请求的操作后，会向CPU发出中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。

<div class="title4">具体的切换操作</div>

>虽然切换类型有多种，但是切换的关键步骤是一致的，都相当于执行了一个中断响应——系统调用实际是中断机制实现的，而异常和中断处理机制实际上也是一致的。

步骤：
1. 从当前进程的描述符中提取内核栈的ss0和esp0信息

2. 保存当前进程信息(cs,eip,eflas,ss,esp)。（这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令）
3. 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转入了内核态的程序执行了。

-----
<div class="title3">参考</div>

[操作系统的内核态和用户态](https://blog.csdn.net/u014229282/article/details/109296005?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162702200616780271521174%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162702200616780271521174&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-109296005.first_rank_v2_pc_rank_v29&utm_term=%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2&spm=1018.2226.3001.4187)  
[*Linux下如何从用户态切换到内核态？](https://blog.csdn.net/shanghx_123/article/details/83151064?ops_request_misc=&request_id=&biz_id=102&utm_term=%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-.nonecase&spm=1018.2226.3001.4187)  
[用户态与内核态的切换与区别](https://blog.csdn.net/u014142287/article/details/51934940?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162702200616780271521174%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162702200616780271521174&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51934940.first_rank_v2_pc_rank_v29&utm_term=%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2&spm=1018.2226.3001.4187)  
[*操作系统用户态和内核态之间的切换过程](https://blog.csdn.net/ddna/article/details/4941373?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162702200616780271521174%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162702200616780271521174&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-4941373.first_rank_v2_pc_rank_v29&utm_term=%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2&spm=1018.2226.3001.4187)

-----