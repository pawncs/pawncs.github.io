---
title: 并发和线程
date: 2021-03-09 20:28:37
categories:
- Java
tags:
---
<style>
.title1{
    font-size:36px;
    color:#e7767f;
    /* 桃红 */

}
.title2{
    font-size:29px;
    color:#176f58;
    /* 祖母绿 */
}
.title3{
    font-size:22px;
    color:#21a675;
    /* 石绿 */
}
.title4{
    font-size:15px;
    color:#a8cd34;
    /* 柳绿 */
}
.name{

    margin-left: auto;
    text-align: right;
    color: #d05667;
    margin-right: 10px;
    margin-top: 20px;
    /*海棠红*/
}
</style>


<div class="name">by pawncs</div>

-----
<div class="title2">零、目录</div>

-----
+ <a href="#并发和线程-part1">一、线程锁</a>
+ <a href="#并发和线程-part2">二、并发容器</a>
+ <a href="#并发和线程-part3">三、线程池</a>
+ <a href="#并发和线程-partEX">EX、额外</a>

-----
<div class="title2" id="#并发和线程-part2">一、线程锁</div>

-----
<div class="title3">1.1、synchronized ——线程同步锁</div>  

+ 可以作用在方法上，表明此方法只能由一个线程执行  
  `public synchronized void sell(){/**todo*/}`
+ `synchronized` 保护了关键方法，不允许其同事执行，必须一个个执行
+ `凡事，都有代价`（错乱）。`synchronized`的性能不高。因为其在运行时，其他线程都要等待，响应慢。
+ 适用范围：写操作的场景；尽量锁尽可能小的代码段
+ `synchronized` 满足原子性和可见性

<div class="title3">1.2、乐观锁和悲观锁</div>

+ 乐观锁：
  + `AtomicInteger`类的`incrementAndGet()`等方法。  
  其本质是不上锁，总是基于最新的数据进行更新。由于没上锁，所以提高了性能。不上锁的思想是乐观的，所以称之为乐观锁。（`AtomicBoolean`……）
+ 悲观锁：  
  恰恰相反，`synchronized`关键字将方法执行前上锁，她假设了其他线程一定会修改数据，所以提前防范。上锁思想是悲观的，所以称之为悲观锁。
+ 乐观锁适用于读数据比重更大的应用场景，悲观锁适用于写数据比重更大的应用场景。


-----
<div class="title2" id="并发和线程-part2">二、并发容器</div>

-----
<div class="title3">2.1 CompletableFuture</div>

+ 是JAVA8的新特性
+ 基本的多线程不利于任务的管理，因此使用`CompletableFuture`
  + `CompletableFuture.supplyAsync(()->{})`方法运行异步任务并返回结果。他会将其参数（一个表达式）包装在一个新的类里（JDK内置），该类实现了`Runable`。（本质是在另一个线程里运行代码）
  
  + 注册新的线程完毕后，使用`thenAccept()`方法（参数是之前的返回结果），自动执行下一个任务。（链式？）。其通常位于任务链的末尾。
  + 中间如果有多步，使用`thenApply()`。使用方式如前。需要返回一个参数作为链的下一步的参数。

  + `CompletableFuture`的任务链的返回值是`CompletableFuture<T>`，（若无返回值则T为void）。
  + 如果需要等待其执行完，就需要等待所有任务线程执行完毕。（`get（）`方法）。下放示例代码中的`allOf()`方法目的是收集所有`CompletableFuture`对象（只支持数组）
~~~java
  List<CompletableFuture> cfs = new ArrayList<>();
    studentList.forEach(s -> {
  CompletableFuture<Void> cf = CompletableFuture.supplyAsync(() -> {
      //todo 
      });
  cfs.add(cf);
});

try {
  // 等待所有的线程执行完毕
  CompletableFuture.allOf(cfs.toArray(new CompletableFuture[] {})).get();
} catch (Exception e) {
  e.printStackTrace();
}
~~~
  + `CompletableFuture`对于不同的任务是并行的，但对于同一个任务是串行的。
  + 有点像`parallelStream()`,不同的是前者注重的是流的元素的计算，后者的任务较为宽泛。
> 在方法执行的时候，需要等待执行完成获得返回值就是同步，不等待继续执行程序就是异步。采用异步方式能支持多个任务并行执行，这种机制就是并发。`CompletableFuture`中，编排的任务是异步的，`get()`方法是同步的。

> 实际上并发容器内部是由线程池实现的。我们也可以指定用哪个线程池运行任务：（第二个参数指定）`CompletableFuture.supplyAsync(
    () -> reg.regId(s),
    EXECUTOR_SERVICE
  )`。当遇到并发度高，任务执行慢的情况，就手动指定线程池，严格控制线程任务了。

> 如果企业技术升级较慢，还处于java6时代，那么线程池就够了，java8就得用并发容器了。

-----
<div class="title2" id="并发和线程-part3">三、线程池</div>

-----
+ 为了复用Thread对象，不用每次创建新的线程，引入了线程池的技术。（线程可以复用，可以执行A任务，也可以执行B任务）

~~~java
//创建线程池核心代码
import org.apache.commons.lang3.concurrent.BasicThreadFactory;

import java.util.concurrent.*;

public class StudentIDTest {

  // 线程工厂
  private static final ThreadFactory namedThreadFactory = new BasicThreadFactory.Builder()
    .namingPattern("studentReg-pool-%d")
    .daemon(true)
    .build();

  // 等待队列
  private static final BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>(1024);

  // 线程池服务
  private static final ThreadPoolExecutor EXECUTOR_SERVICE = new ThreadPoolExecutor(
        20,
        200,
        30,
        TimeUnit.SECONDS,
        workQueue,
        namedThreadFactory,
        new ThreadPoolExecutor.AbortPolicy()
      );

  public static void main(String[] args) {

  }
}
~~~

>需要引入依赖
~~~xml
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-lang3</artifactId>
  <version>3.10</version>
</dependency>
~~~

<div class="title3">3.1 创建线程工厂实例</div>

~~~java
new BasicThreadFactory.Builder()
  .namingPattern("xxx-pool-%d")
  .daemon(true)
  .build();
~~~
>其中`namingPattern()`方法是为了定义线程名字格式。(修改xxx).
<div class="title3">3.2 创建线程等待实例</div>

~~~java
new LinkedBlockingQueue<Runnable>(2048);//6核，8核。1，2核就512.
~~~
<div class="title3">3.2 创建线程池实例</div>

+ 创建`ThreadPoolExecutor`实例。 
>构造函数参数说明
<table>
<tr><th>参数序号</th><th>解释</th></tr>
<tr><td>1</td><td>线程池初始化核心线程数量（一般两位数）</td></tr>
<tr><td>2</td><td>线程池最大线程数（通常不超过200）</td></tr>
<tr><td>3</td><td>线程数超过核心线程数时，如果没有任务经过多久回收（立即回收：0，通常30）</td></tr>
<tr><td>4</td><td>第三个参数的时间单位（TimeUnit.SECONDS）</td></tr>
<tr><td>5</td><td>等待队列实例</td></tr>
<tr><td>6</td><td>线程工厂实例</td></tr>
<tr><td>7</td><td>任务超过队列容量时，采用什么策略（AbortPolicy表拒绝，主程序自己处理）</td></tr>
</table>

>线程池可以防止线程过多，做到对线程的精确控制
~~~java
//执行
Thread t = new Thread(runAbleImpl);
t.start();
//-->
EXECUTOR.execute(runAbleImpl);
//EXECUTOR是ThreadPoolExecutor的实例，是static final对象。
~~~

-----
<div class="title2" id="并发和线程-partEX">EX、其他</div>

-----
+ 获得当前运行的线程的名字  
  `Thread.currentThread().getName()`

-----