---
title: 设计模式
date: 2021-03-07 20:44:23
categories:
- Java
tags:
- Design Pattern
---
<style>
.title1{
    font-size:36px;
    color:#e7767f;
    /* 桃红 */

}
.title2{
    font-size:29px;
    color:#176f58;
    /* 祖母绿 */
}
.title3{
    font-size:22px;
    color:#21a675;
    /* 石绿 */
}
.title4{
    font-size:15px;
    color:#a8cd34;
    /* 柳绿 */
}
.name{

    margin-left: auto;
    text-align: right;
    color: #d05667;
    margin-right: 10px;
    margin-top: 20px;
    /*海棠红*/
}
</style>

<div class="name">by pawncs</div>

-----
<div class="title2">一、单例模式</div>

-----
+ 保证只有一个实例对象的方式，就是单例模式。  
  + 实现方式可以将构造方法私有化，同时增加私有的静态实例，访问该对象即访问唯一实例（也可以在访问时再初始化）。命名：`XXXInstance`
+ 单例模式可以节约系统资源
-----
<div class="title2">二、简单工厂模式</div>

-----
+ 工厂——生产实例(命名为`XXXFactory`)
  + 实现根据不同要求产生不同对象的功能
 ~~~java
 public class FruitFactory {
    public static Fruit getFruit(Customer customer) {
        Fruit fruit = null;
        if ("sweet".equals(customer.getFlavor())) {
            fruit = new Watermelon();
        } else if ("acid".equals(customer.getFlavor())) {
            fruit = new Lemon();
        } else if ("smelly".equals(customer.getFlavor())) {
            fruit = new Durian();
        }

        return fruit;
    }
}
 ~~~
+ 优点是职责明确

+ 实现接口的每个类具有相同的方法，为了防止出现重复代码，可以加个继承的抽象类。

-----
<div class="title2">三、抽象工厂模式</div>

-----
+ 实质是工厂的工厂，将工厂进一步抽象
~~~java
  public interface SnacksFactory {
    // 取得水果
    public Fruit getFruit(Customer customer);
    // 取得饮料
    public Drink getDrink(Customer customer);
}

public class SnacksFactoryBuilder {
    public SnacksFactory buildFactory(String choice) {
        if (choice.equalsIgnoreCase("fruit")) {
            return new FruitFactory();
        } else if (choice.equalsIgnoreCase("drink")) {
            return new DrinkFactory();
        }
        return null;
    }
}
~~~

-----
<div class="title2">四、观察者模式</div>

-----
适合“订阅/通知的场景”

1. 观察什么  
   观察被观察者。被观察者需继承` Observable`类。  
   ~~~java
   //告诉父类被观察者已改变
    super.setChanged();
    // 发出通知，参数是额外的信息
    super.notifyObservers("XXX");
   ~~~
2. 谁接受通知  
   观察者接受通知，需继承`Observer`类  
   需实现`update`方法。其中第一个参数是被观察者（已继承`Observable`）,第二个参数是额外的信息（`notifyObservers`传入的对象）
   ~~~java
   @Override
    public void update(Observable o, Object arg) {
        
    }
   ~~~
3. 怎么接受通知  
   被观察者调用方法`addObserver()`添加观察者。
-----