---
title: 线程池概览
date: 2022-03-25 13:44:27
categories:
- Java
tags:
- ThreadPool
---
<style>
.title1{
    font-size:36px;
    color:#e7767f;
    /* 桃红 */

}
.title2{
    font-size:29px;
    color:#176f58;
    /* 祖母绿 */
}
.title3{
    font-size:22px;
    color:#21a675;
    /* 石绿 */
}
.title4{
    font-size:15px;
    color:#a8cd34;
    /* 柳绿 */
}
.name{

    margin-left: auto;
    text-align: right;
    color: #d05667;
    margin-right: 10px;
    margin-top: 20px;
    /*海棠红*/
}
</style>

>线程池作用：
>+ 降低资源损耗（不用频繁创建销毁）
>
>+ 提高响应速度（任务到达时不必等待线程创建）
>
>+ 提高线程可管理性（方便统一分配、调优、监控）

<div class="name">by pawncs</div>

-----
<div class="title2">零、目录</div>

-----

+ <a href="#ThreadPool-1">一、线程池构造七参数概览</a>
+ <a href="#ThreadPool-2">二、提交任务后线程池处理流程</a>
+ <a href="#ThreadPool-3">三、线程池使用</a>
    + 任务队列种类
    + 饱和策略
    + 合理配置线程池
+ <a href="#ThreadPool-4">四、线程池监控</a>
+ <a href="#ThreadPool-EX">EX、附录</a>

-----
<div class="title2" id="ThreadPool-1">一、线程池构造七参数概览</div>

-----

+ 创建`ThreadPoolExecutor`实例。 
>构造函数参数说明
<table>
<tr><th>参数序号</th><th>解释</th></tr>
<tr><td>1</td><td>线程池初始化核心线程数量（一般两位数）</td></tr>
<tr><td>2</td><td>线程池最大线程数（通常不超过200）</td></tr>
<tr><td>3</td><td>线程数超过核心线程数时，如果没有任务经过多久回收（立即回收：0，通常30）</td></tr>
<tr><td>4</td><td>第三个参数的时间单位（TimeUnit.SECONDS）</td></tr>
<tr><td>5</td><td>等待队列实例</td></tr>
<tr><td>6</td><td>线程工厂实例</td></tr>
<tr><td>7</td><td>任务超过队列容量时，采用什么策略（AbortPolicy表拒绝，主程序自己处理）</td></tr>
</table>

~~~java
//创建线程池核心代码
import org.apache.commons.lang3.concurrent.BasicThreadFactory;

import java.util.concurrent.*;

public class StudentIDTest {

  // 线程工厂
  private static final ThreadFactory namedThreadFactory = new BasicThreadFactory.Builder()
    .namingPattern("studentReg-pool-%d")
    .daemon(true)
    .build();

  // 等待队列
  private static final BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>(1024);

  // 线程池服务
  private static final ThreadPoolExecutor EXECUTOR_SERVICE = new ThreadPoolExecutor(
        20,
        200,
        30,
        TimeUnit.SECONDS,
        workQueue,
        namedThreadFactory,
        new ThreadPoolExecutor.AbortPolicy()
      );

  public static void main(String[] args) {

  }
}
~~~
-----
<div class="title2" id="ThreadPool-2">二、提交任务后线程池处理流程</div>

-----
1. `判断核心线程池所有线程是否都被创建`。若不是，则<strong>创建</strong>新的工作线程执行任务。否则进入2.(涉及参数1，需获取全局锁)
    注：哪怕已创建线程空闲也会创建新线程

2. 判断工作队列是否已满。若未满，则将新提交的任务储存在工作队列里。否则进入3.(涉及参数5)

3. 判断线程池的线程是否都处于工作状态，若无，则<strong>创建</strong>新的工作线程执行任务。否则，进入4。(涉及参数2，需获取全局锁)（若工作队列为无界，则永远无效）

4. 根据饱和策略进行处理（调用`RejectedExecutionHandler.rejectedExecution()`）

设计的主要思路：尽可能避免获取全局锁。当`ThreadPoolExecutor`完成预热后(当前运行的线程数大于核心线程数)，几乎所有的`execute()`都是执行步骤2,而这一步不需要全局锁。

-----
<div class="title2" id="ThreadPool-3">三、线程池使用</div>

-----
<div class="title3" id="ThreadPool-3-1">3.1 任务队列(runnable TaskQueue)的种类</div>

+ `ArrayBlockingQueue`：基于数组结构的有界阻塞队列。FIFO原则排序(先进先出)


+ `LinkedBlockingQueue`：基于链表结构的阻塞队列。FIFO原则排序，吞吐量通常高于`ArrayBlockingQueue`

+ `SynchronousQueue`：不存储元素的阻塞队列。每个插入操作要等到另一线程调用移除操作，否则插入操作一直阻塞。吞吐量通常高于`LinkedBlockingQueue`

+ `PriorityBlockingQueue`:具有优先级的无限阻塞队列

>注： 建议使用有界队列，可以增强系统的稳定性和预警能力

<div class="title3" id="ThreadPool-3-2">3.2 四种饱和策略(RejectedExecutionHandler)</div>

+ `AbortPolicy`:直接抛异常

+ `CallerRunsPolicy`:用调用者的线程来运行任务
+ `DiscardOldestPolicy`:丢弃队列里最近的任务，并执行当前任务
+ `DiscardPolicy`:不进行处理，丢弃掉

<div class="title3" id="ThreadPool-3-3">3.3 合理配置线程池</div>

>根据任务性质(CPU密集型、IO密集型、混合型任务)、优先级、执行时间、依赖性(如是否依赖其他系统资源，如数据库连接)来配置线程池。  

任务性质：
+ CPU密集型：配置Ncpu+1个线程的线程池。  
+ IO密集型：由于并不是一直在执行任务，所以应配置尽可能多的线程，如2*Ncpu.  
+ 混合型：可拆成CPU密集型任务和IO密集型任务，并行处理吞吐量更高。若两个任务执行时间差距太大，则不必拆分。
> 注：可通过`Runtime.getRuntime().availableProcessors()`方法获得当前设备的CPU个数。

优先级：
+ 通过优先级队列处理。
>注：若优先级高的任务一直提交，则低优先级任务永远不会被执行

执行时间：
+ 交给不同规模的线程池来处理，或者使用优先级队列（先处理时间短的）

外部依赖（数据库连接池）：
+ 因为要等待返回结果，等待时间越长，CPU空闲越长，则线程数就应该设置的越大。

-----
<div class="title2" id="ThreadPool-4">四、线程池监控</div>

-----
>方便线程池出现问题时快速定位。可通过以下参数进行监控

+ taskCount：线程池需要执行的任务数量

+ completedTaskCount：线程池运行过程中已完成任务数量（小于等于taskCount）

+ largestPoolSize：线程池曾经创建过的最大线程数量。（可以得知是否曾经满过）（若等于线程池最大大小，则表示曾经满过）

+ getPoolSize：线程池线程数量（书上说线程池不销毁则线程不会自动销毁，所以只增不减，和现实相悖）

+ getActiveCount：获取活动线程数

可以通过继承线程池来自定义线程池，重写`beforeExecute`、`afterExecute`和`terminated`方法,来完成线程池的监控。

-----
<div class="title2" id="ThreadPool-EX">EX、附录</div>

-----

相关笔记：[并发与线程](https://pawncs.github.io/2021/03/09/%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/)

参考书籍：《并发编程的艺术》.方腾飞 魏鹏 程晓明.华章分社.电子版

-----